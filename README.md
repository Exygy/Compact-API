# Compact-API
A NestJS API template to be used to create small single-purpose services 


![TypeScript](https://img.shields.io/badge/typescript-%23007ACC.svg?style=for-the-badge&logo=typescript&logoColor=white) ![NestJS](https://img.shields.io/badge/nestjs-%23E0234E.svg?style=for-the-badge&logo=nestjs&logoColor=white) ![Prisma](https://img.shields.io/badge/Prisma-3982CE?style=for-the-badge&logo=Prisma&logoColor=white) ![Postgres](https://img.shields.io/badge/postgres-%23316192.svg?style=for-the-badge&logo=postgresql&logoColor=white)

## Overview

This is a template for an API connected to a database. Data is stored in a [Postgres](https://www.postgresql.org/) database and served over HTTPS to the requester. Most services are part of a [NestJS](https://nestjs.com/) application. [Prisma](https://www.prisma.io/) is the application's ORM. [OpenAPI Swagger](https://swagger.io/tools/swagger-ui/) documentation is automatically generated by the server at http://localhost:<i>port env variable </i>>/api/ in local development environments, or in any other environment by adding `/api` to the api URL. This can be helpful to get a more visual overview of all available endpoints.

## Installation

The following commands are for macOS / Linux, but you can find equivalent instructions for Windows machines online.

### Environment Variables

Configuration of the API is pulled from environment variables defined in an `.env` file in the api directory. Copy the `.env.template` file in api into a `.env` file. Some keys are secret and are internally available. The template file includes default values and descriptions of each variable.

### Dependencies

If you don't have yarn installed, you can install homebrew with [these instructions](https://brew.sh/) and then do so with `brew install yarn`.

#### Installing Node

We are currently using Node version 20. You can install Node using homebrew with the following command: `brew install node@20`.

If you have multiple versions of Node installed, you can use [nvm](https://github.com/nvm-sh/nvm) (node version manager), brew, or other similar tools, to switch between them. Ensure you're on the right version by checking with `node -v`.

If along the way you get `env: node: No such file or directory`, inspect the output from installing node for instructions on if you might need to add node to certain terminal paths.

#### Installing Postgresql

You can install Postgres using homebrew with the following command: `brew install postgresql@15`. You then start it with `brew services start postgresql@15`.

#### Project dependencies

Install project dependencies with `yarn install` from within the api directory.

## Starting locally

The following command will generate and build the Prisma schema and setup the database with seeded data: `yarn setup`.

If this is your first time running this command and you see `psql: error: FATAL: database "<username>" does not exist` you may need to run `createdb <username>` first.

You will also need to update the `DATABASE_URL` environment variable to include your username.

If you're using VSCode, you can install [the Postgres explorer extension](https://marketplace.visualstudio.com/items?itemName=ckolkman.vscode-postgres) to inspect your local database. When you click on the + to create a new connection, you can use the following inputs to each question to create a connection to the newly created database: `localhost`, `<username>`, hit enter for password, `5432`, standard, the name of your database, and a descriptive name like `local-api`. Once the connection is established, you can inspect the database.

To start the application run: `yarn dev`.

## Modifying the Schema

If you're using VSCode, you can install the [Prisma extension](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma) to add syntax highlighting and formatting to Prisma schema files.

To modify the Prisma schema you will need to work with the <b>schema.prisma</b> file. This file controls the following:

<ol>
  <li> The Structure of each model </li>
  <li> The Relationships between models </li>
  <li> Enum creation for use in both the API and the database </li>
  <li> How Prisma connects to the database </li>
</ol>

You will need to:

1. Add the field in the DTO
2. Run `yarn generate:client` to add the type to the swagger file
3. Manually add the field to `schema.prisma`
4. Run `yarn prisma migrate dev --name <name of migration>` to create the migration file

### Conventions

We use the following conventions:

<ul>
  <li> model and enum names are capitalized camel case (e.g. HelloWorld) </li>
  <li> model and enum names are <b>@@map()</b>ed to lowercase snake case (e.g. hello_world) </li>
  <li> model names are always plural (e.g. `Applicants` for the model and `applicants` for the <b>@@map()</b>ed version) </li>
  <li> a model's fields are lowercase camel case (e.g. helloWorld) </li>
  <li> a model's fields are <b>@map()</b>ed to lowercase snake case (e.g. hello_world) </li>
</ul>
This is to make the api easier to work with, and to respect postgres's name space conventions.
<p></p>

## Controllers

Endpoints live in controllers under `src/controllers`. They follow the [NestJs standards](https://docs.nestjs.com/controllers)

### Conventions

Controllers are given the extension `.controller.ts` and the model name (listing, application, etc) is singular. So for example `listing.controller.ts`.

The exported class should be in capitalized camel case (e.g. `ListingController`).

## DTOs

DTOs (Data Transfer Objects) are how we flag what fields endpoints will take in, and what the form of the response from the api will be.

We use the packages [class-transformer](https://www.npmjs.com/package/class-transformer) & [class-validator](https://www.npmjs.com/package/class-validator) for this.

DTOs are stored under `src/dtos`, and are broken up by what model they are related to. There are also shared DTOs which are stored under the shared sub-directory.

### Conventions

DTOs are given the extension `.dto.ts` and the file name is lowercase kebab case (e.g. `listings-filter-params.dto.ts`).

The exported class should be in capitalized camel case (e.g. `ListingFilterParams`) and does not include the DTO as a suffix.

## Enums

These are enums used by NestJs primarily for either taking in a request or sending out a response. Database enums (enums from Prisma) are part of the Prisma schema and are not housed here.

They are housed under `src/enums` and the file name is lowercase kebab case and end with `-enum.ts`.

So for example `filter-key-enum.ts`.

### Conventions

The exported enum should be in capitalized camel case (e.g. `ListingFilterKeys`).

## Modules

Modules connect the controllers to services and follow [NestJS standards](https://docs.nestjs.com/modules).

### Conventions

Modules are housed under `src/modules` and are given the extension `.module.ts`. The model name (listing, application, etc) is singular. So for example `listing.module.ts`.

The exported class should be in capitalized camel case (e.g. `ListingModule`).

## Services

Services are where business logic is performed as well as interfacing with the database.

Controllers should be calling functions in services in order to do their work.

They follow the [NestJS standards](https://docs.nestjs.com/providers).

### Conventions

Services are housed under `src/services` and are given the extension `.services.ts`. The model name (listing, application, etc) is singular. So for example `listing.service.ts`.

The exported class should be in capitalized camel case (e.g. `ListingService`).

## Guards

We use 2 guards: ThrottleGuard and ApiKeyGuard.

ThrottleGuard acts as a rate limiter for the API. Its done on an IP basis. 

ApiKeyGuard is something that was built to prevent access to the API from sources without the secret pass key. It requires that secret pass key to be passed in the request header. Any request that does not have that info while the `API_PASS_KEY` env variable is set will be rejected.

## Testing

There are 2 different kinds of tests that the api supports: Integration tests and Unit tests.

Integration Tests are tests that DO interface with the database, reading/writing/updating/deleting data from that database.

Unit Tests are tests that MOCK interaction with the database, or test functionality directly that does not interact with the database.

### Integration Testing

Integration Tests are housed under `test/integration`, and files are given the extension `.e2e-spec.ts`.

These tests will generally test going through the controller's endpoints and will mock as little as possible. Since the order of tests executing can't be guaranteed, tests should be written with the possibility of other tests having run first in mind. One cannot assume that the database will be empty prior to the test running.

#### How to run integration tests

Running the following will run all integration tests `yarn test:e2e`.

### Unit Testing

Unit Tests are housed under `test/unit`, and files are given the extension `.spec.ts`.

These tests will generally test the functions of a service, or helper functions.
These tests will mock Prisma and therefore will not interface directly with the database. This allows for verifying the correct business logic is performed without having to set up the database.

#### How to run unit tests

Running the following will run all unit tests: `yarn test`

### Testing with code coverage

We have set up both code coverage and code coverage benchmarks. These benchmarks must be met for your PR to pass CI checks. Test coverage is calculated against both the integration and unit test runs. You can run test coverage with the following: `yarn test:cov`
